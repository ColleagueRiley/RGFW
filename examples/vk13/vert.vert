#version 450

layout (location = 0) out vec2 outUV;
layout (location = 1) out vec3 outNormal;

layout(push_constant, std430) uniform pc {
	mat4 mvp;
};

vec3 cube_v[36] = vec3[](
	// front
	vec3(-1.0, -1.0, 1.0), vec3(1.0, -1.0, 1.0), vec3(1.0, 1.0, 1.0),
	vec3(-1.0, -1.0, 1.0), vec3(1.0, 1.0, 1.0), vec3(-1.0, 1.0, 1.0),
	// back
	vec3(-1.0, -1.0, -1.0), vec3(-1.0, 1.0, -1.0), vec3(1.0, 1.0, -1.0),
	vec3(-1.0, -1.0, -1.0), vec3(1.0, 1.0, -1.0), vec3(1.0, -1.0, -1.0),
	// top
	vec3(-1.0, 1.0, -1.0), vec3(-1.0, 1.0, 1.0), vec3(1.0, 1.0, 1.0),
	vec3(-1.0, 1.0, -1.0), vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, -1.0),
	// bottom
	vec3(-1.0, -1.0, -1.0), vec3(1.0, -1.0, -1.0), vec3(1.0, -1.0, 1.0),
	vec3(-1.0, -1.0, -1.0), vec3(1.0, -1.0, 1.0), vec3(-1.0, -1.0, 1.0),
	// left
	vec3(-1.0, -1.0, -1.0), vec3(-1.0, 1.0, 1.0), vec3(-1.0, 1.0, -1.0),
	vec3(-1.0, -1.0, -1.0), vec3(-1.0, -1.0, 1.0), vec3(-1.0, 1.0, 1.0),
	// right
	vec3(1.0, -1.0, 1.0), vec3(1.0, -1.0, -1.0), vec3(1.0, 1.0, -1.0),
	vec3(1.0, -1.0, 1.0), vec3(1.0, 1.0, -1.0), vec3(1.0, 1.0, 1.0)
);

vec2 cube_uv[36] = vec2[]( // thanks grok
	// front
	vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(1.0, -1.0),
	vec2(0.0, 0.0), vec2(1.0, -1.0), vec2(0.0, -1.0),
	// back
	vec2(0.0, 0.0), vec2(0.0, -1.0), vec2(1.0, -1.0),
	vec2(0.0, 0.0), vec2(1.0, -1.0), vec2(1.0, 0.0),
	// top
	vec2(0.0, 0.0), vec2(0.0, -1.0), vec2(1.0, -1.0),
	vec2(0.0, 0.0), vec2(1.0, -1.0), vec2(1.0, 0.0),
	// bottom
	vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(1.0, -1.0),
	vec2(0.0, 0.0), vec2(1.0, -1.0), vec2(0.0, -1.0),
	// left
	vec2(0.0, 0.0), vec2(1.0, -1.0), vec2(0.0, -1.0),
	vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(1.0, -1.0),
	// right
	vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(1.0, -1.0),
	vec2(0.0, 0.0), vec2(1.0, -1.0), vec2(0.0, -1.0)
);

vec3 cube_n[36] = vec3[](
	// front (normal: 0, 0, 1)
	vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 1.0),
	vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 1.0),
	// back (normal: 0, 0, -1)
	vec3(0.0, 0.0, -1.0), vec3(0.0, 0.0, -1.0), vec3(0.0, 0.0, -1.0),
	vec3(0.0, 0.0, -1.0), vec3(0.0, 0.0, -1.0), vec3(0.0, 0.0, -1.0),
	// top (normal: 0, 1, 0)
	vec3(0.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0),
	vec3(0.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0),
	// bottom (normal: 0, -1, 0)
	vec3(0.0, -1.0, 0.0), vec3(0.0, -1.0, 0.0), vec3(0.0, -1.0, 0.0),
	vec3(0.0, -1.0, 0.0), vec3(0.0, -1.0, 0.0), vec3(0.0, -1.0, 0.0),
	// left (normal: -1, 0, 0)
	vec3(-1.0, 0.0, 0.0), vec3(-1.0, 0.0, 0.0), vec3(-1.0, 0.0, 0.0),
	vec3(-1.0, 0.0, 0.0), vec3(-1.0, 0.0, 0.0), vec3(-1.0, 0.0, 0.0),
	// right (normal: 1, 0, 0)
	vec3(1.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0),
	vec3(1.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0)
);

vec3 positions[3] = vec3[](
	vec3(1.0, 1.0, 0.0),
	vec3(-1.0, 1.0, 0.0),
	vec3(0.0, -1.0, 0.0)
);

void main(void)
{
	outUV = cube_uv[gl_VertexIndex];
	outNormal = cube_n[gl_VertexIndex] * mat3(mvp);
	gl_Position = vec4(cube_v[gl_VertexIndex], 1.0) * mvp;
}
