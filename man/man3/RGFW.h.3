.TH "RGFW.h" 3 "Sun Oct 5 2025" "RGFW" \" -*- nroff -*-
.ad l
.nh
.SH NAME
RGFW.h
.SH SYNOPSIS
.br
.PP
\fC#include <stdlib\&.h>\fP
.br
\fC#include <assert\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <stddef\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBRGFW_monitorMode\fP"
.br
.ti -1c
.RI "struct \fBRGFW_monitor\fP"
.br
.ti -1c
.RI "struct \fBRGFW_commonEvent\fP"
.br
.ti -1c
.RI "struct \fBRGFW_mouseButtonEvent\fP"
.br
.ti -1c
.RI "struct \fBRGFW_mouseScrollEvent\fP"
.br
.ti -1c
.RI "struct \fBRGFW_mousePosEvent\fP"
.br
.ti -1c
.RI "struct \fBRGFW_keyEvent\fP"
.br
.ti -1c
.RI "struct \fBRGFW_dataDropEvent\fP"
.br
.ti -1c
.RI "struct \fBRGFW_dataDragEvent\fP"
.br
.ti -1c
.RI "struct \fBRGFW_scaleUpdatedEvent\fP"
.br
.ti -1c
.RI "union \fBRGFW_event\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBRGFW_USERPTR\fP   NULL"
.br
.ti -1c
.RI "#define \fBRGFW_UNUSED\fP(x)   (void)(x)"
.br
.ti -1c
.RI "#define \fBRGFW_ROUND\fP(x)   (\fBi32\fP)((x) >= 0 ? (x) + 0\&.5f : (x) \- 0\&.5f)"
.br
.ti -1c
.RI "#define \fBRGFW_MIN\fP(x,  y)   ((x < y) ? x : y)"
.br
.ti -1c
.RI "#define \fBRGFW_ALLOC\fP   malloc"
.br
.ti -1c
.RI "#define \fBRGFW_FREE\fP   free"
.br
.ti -1c
.RI "#define \fBRGFW_ASSERT\fP   assert"
.br
.ti -1c
.RI "#define \fBRGFW_MEMSET\fP(ptr,  value,  num)   memset(ptr, value, num)"
.br
.ti -1c
.RI "#define \fBRGFW_MEMCPY\fP(dist,  src,  len)   memcpy(dist, src, len)"
.br
.ti -1c
.RI "#define \fBRGFW_STRNCMP\fP(s1,  s2,  max)   strncmp(s1, s2, max)"
.br
.ti -1c
.RI "#define \fBRGFW_STRNCPY\fP(dist,  src,  len)   strncpy(dist, src, len)"
.br
.ti -1c
.RI "#define \fBRGFW_STRSTR\fP(str,  substr)   strstr(str, substr)"
.br
.ti -1c
.RI "#define \fBRGFW_STRTOL\fP(str,  endptr,  base)   strtol(str, endptr, base)"
.br
.ti -1c
.RI "#define \fBRGFW_ATOF\fP(num)   atof(num)"
.br
.ti -1c
.RI "#define \fBRGFW_MAX_PATH\fP   260 /* max length of a path (for drag andn drop) */"
.br
.ti -1c
.RI "#define \fBRGFW_MAX_DROPS\fP   260 /* max items you can drop at once */"
.br
.ti -1c
.RI "#define \fBRGFW_COCOA_FRAME_NAME\fP   NULL"
.br
.ti -1c
.RI "#define \fBRGFWDEF\fP   inline"
.br
.ti -1c
.RI "#define \fBRGFW_HEADER\fP"
.br
.ti -1c
.RI "#define \fBRGFW_INT_DEFINED\fP"
.br
.ti -1c
.RI "#define \fBRGFW_BOOL_DEFINED\fP"
.br
.ti -1c
.RI "#define \fBRGFW_BOOL\fP(x)   (\fBRGFW_bool\fP)((x) != 0) /* force a value to be 0 or 1 */"
.br
.ti -1c
.RI "#define \fBRGFW_TRUE\fP   (\fBRGFW_bool\fP)1"
.br
.ti -1c
.RI "#define \fBRGFW_FALSE\fP   (\fBRGFW_bool\fP)0"
.br
.ti -1c
.RI "#define \fBRGFW_ENUM\fP(type,  name)   type name; enum"
.br
.ti -1c
.RI "#define \fBRGFW_BIT\fP(x)   (1 << (x))"
.br
.ti -1c
.RI "#define \fBRGFW_MAX_MONITORS\fP   6"
.br
.ti -1c
.RI "#define \fBRGFW_MAX_EVENTS\fP   32"
.br
.ti -1c
.RI "#define \fBRGFW_eventQueuePushEx\fP(eventInit)   { \fBRGFW_event\fP e; eventInit; \fBRGFW_eventQueuePush\fP(&e); }"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef uint8_t \fBu8\fP"
.br
.ti -1c
.RI "typedef int8_t \fBi8\fP"
.br
.ti -1c
.RI "typedef uint16_t \fBu16\fP"
.br
.ti -1c
.RI "typedef int16_t \fBi16\fP"
.br
.ti -1c
.RI "typedef uint32_t \fBu32\fP"
.br
.ti -1c
.RI "typedef int32_t \fBi32\fP"
.br
.ti -1c
.RI "typedef uint64_t \fBu64\fP"
.br
.ti -1c
.RI "typedef int64_t \fBi64\fP"
.br
.ti -1c
.RI "typedef \fBu8\fP \fBRGFW_bool\fP"
.br
.ti -1c
.RI "typedef struct \fBRGFW_window\fP \fBRGFW_window\fP"
.br
.ti -1c
.RI "typedef struct \fBRGFW_window_src\fP \fBRGFW_window_src\fP"
.br
.ti -1c
.RI "typedef struct \fBRGFW_nativeImage\fP \fBRGFW_nativeImage\fP"
.br
.ti -1c
.RI "typedef struct \fBRGFW_surface\fP \fBRGFW_surface\fP"
.br
.ti -1c
.RI "typedef void \fBRGFW_mouse\fP"
.br
.ti -1c
.RI "typedef struct \fBRGFW_monitorMode\fP \fBRGFW_monitorMode\fP"
.br
.ti -1c
.RI "typedef struct \fBRGFW_monitor\fP \fBRGFW_monitor\fP"
.br
.ti -1c
.RI "typedef struct \fBRGFW_commonEvent\fP \fBRGFW_commonEvent\fP"
.br
.ti -1c
.RI "typedef struct \fBRGFW_mouseButtonEvent\fP \fBRGFW_mouseButtonEvent\fP"
.br
.ti -1c
.RI "typedef struct \fBRGFW_mouseScrollEvent\fP \fBRGFW_mouseScrollEvent\fP"
.br
.ti -1c
.RI "typedef struct \fBRGFW_mousePosEvent\fP \fBRGFW_mousePosEvent\fP"
.br
.ti -1c
.RI "typedef struct \fBRGFW_keyEvent\fP \fBRGFW_keyEvent\fP"
.br
.ti -1c
.RI "typedef struct \fBRGFW_dataDropEvent\fP \fBRGFW_dataDropEvent\fP"
.br
.ti -1c
.RI "typedef struct \fBRGFW_dataDragEvent\fP \fBRGFW_dataDragEvent\fP"
.br
.ti -1c
.RI "typedef struct \fBRGFW_scaleUpdatedEvent\fP \fBRGFW_scaleUpdatedEvent\fP"
.br
.ti -1c
.RI "typedef union \fBRGFW_event\fP \fBRGFW_event\fP"
.br
.ti -1c
.RI "typedef ptrdiff_t \fBRGFW_ssize_t\fP"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_debugfunc\fP) (RGFW_debugType type, RGFW_errorCode err, const char *msg)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_windowMovedfunc\fP) (\fBRGFW_window\fP *win, \fBi32\fP x, \fBi32\fP y)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_windowResizedfunc\fP) (\fBRGFW_window\fP *win, \fBi32\fP w, \fBi32\fP h)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_windowRestoredfunc\fP) (\fBRGFW_window\fP *win, \fBi32\fP x, \fBi32\fP y, \fBi32\fP w, \fBi32\fP h)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_windowMaximizedfunc\fP) (\fBRGFW_window\fP *win, \fBi32\fP x, \fBi32\fP y, \fBi32\fP w, \fBi32\fP h)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_windowMinimizedfunc\fP) (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_windowQuitfunc\fP) (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_focusfunc\fP) (\fBRGFW_window\fP *win, \fBRGFW_bool\fP inFocus)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_mouseNotifyfunc\fP) (\fBRGFW_window\fP *win, \fBi32\fP x, \fBi32\fP y, \fBRGFW_bool\fP status)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_mousePosfunc\fP) (\fBRGFW_window\fP *win, \fBi32\fP x, \fBi32\fP y, float vecX, float vecY)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_dataDragfunc\fP) (\fBRGFW_window\fP *win, \fBi32\fP x, \fBi32\fP y)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_windowRefreshfunc\fP) (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_keyfunc\fP) (\fBRGFW_window\fP *win, \fBu8\fP key, \fBu8\fP sym, RGFW_keymod mod, \fBRGFW_bool\fP repeat, \fBRGFW_bool\fP pressed)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_mouseButtonfunc\fP) (\fBRGFW_window\fP *win, RGFW_mouseButton button, \fBRGFW_bool\fP pressed)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_mouseScrollfunc\fP) (\fBRGFW_window\fP *win, float x, float y)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_dataDropfunc\fP) (\fBRGFW_window\fP *win, char **files, size_t count)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_scaleUpdatedfunc\fP) (\fBRGFW_window\fP *win, float scaleX, float scaleY)"
.br
.ti -1c
.RI "typedef void(* \fBRGFW_proc\fP) (void)"
.br
.ti -1c
.RI "typedef struct \fBRGFW_info\fP \fBRGFW_info\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBRGFWDEF\fP void * \fBRGFW_alloc\fP (size_t size)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_free\fP (void *ptr)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP size_t \fBRGFW_sizeofWindow\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP size_t \fBRGFW_sizeofWindowSrc\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_useWayland\fP (\fBRGFW_bool\fP wayland)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_usingWayland\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void * \fBRGFW_getLayer_OSX\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void * \fBRGFW_getDisplay_X11\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP struct wl_display * \fBRGFW_getDisplay_Wayland\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_setClassName\fP (const char *name)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_setXInstName\fP (const char *name)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_moveToMacOSResourceDir\fP (void)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu8\fP, RGFW_format)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_copyImageData\fP (\fBu8\fP *dest_data, \fBi32\fP w, \fBi32\fP h, RGFW_format dest_format, \fBu8\fP *src_data, RGFW_format src_format)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP size_t \fBRGFW_sizeofNativeImage\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP size_t \fBRGFW_sizeofSurface\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_surface\fP * \fBRGFW_createSurface\fP (\fBu8\fP *data, \fBi32\fP w, \fBi32\fP h, RGFW_format format)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_createSurfacePtr\fP (\fBu8\fP *data, \fBi32\fP w, \fBi32\fP h, RGFW_format format, \fBRGFW_surface\fP *surface)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_nativeImage\fP * \fBRGFW_surface_getNativeImage\fP (\fBRGFW_surface\fP *surface)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_surface_free\fP (\fBRGFW_surface\fP *surface)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_surface_freePtr\fP (\fBRGFW_surface\fP *surface)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_mouse\fP * \fBRGFW_loadMouse\fP (\fBu8\fP *data, \fBi32\fP w, \fBi32\fP h, RGFW_format format)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_freeMouse\fP (\fBRGFW_mouse\fP *mouse)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_monitor\fP * \fBRGFW_getMonitors\fP (size_t *len)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_monitor\fP \fBRGFW_getPrimaryMonitor\fP (void)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu8\fP, RGFW_modeRequest)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_monitor_requestMode\fP (\fBRGFW_monitor\fP mon, \fBRGFW_monitorMode\fP mode, RGFW_modeRequest request)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_monitorModeCompare\fP (\fBRGFW_monitorMode\fP mon, \fBRGFW_monitorMode\fP mon2, RGFW_modeRequest request)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_monitor_scaleToWindow\fP (\fBRGFW_monitor\fP mon, struct \fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu8\fP, RGFW_key)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu8\fP, RGFW_mouseButton)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu8\fP, RGFW_keymod)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu8\fP, RGFW_eventType)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu32\fP, RGFW_eventFlag)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBi32\fP, RGFW_eventWait)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_waitForEvent\fP (\fBi32\fP waitMS)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_setQueueEvents\fP (\fBRGFW_bool\fP queue)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_pollEvents\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_stopCheckEvents\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_isKeyPressed\fP (RGFW_key key)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_isKeyDown\fP (RGFW_key key)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_isKeyReleased\fP (RGFW_key key)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_isMousePressed\fP (RGFW_mouseButton button)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_isMouseDown\fP (RGFW_mouseButton button)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_isMouseReleased\fP (RGFW_mouseButton button)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_getMouseScroll\fP (float *x, float *y)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_getMouseVector\fP (float *x, float *y)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu32\fP, RGFW_windowFlags)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_window\fP * \fBRGFW_createWindow\fP (const char *name, \fBi32\fP x, \fBi32\fP y, \fBi32\fP w, \fBi32\fP h, RGFW_windowFlags flags)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_window\fP * \fBRGFW_createWindowPtr\fP (const char *name, \fBi32\fP x, \fBi32\fP y, \fBi32\fP w, \fBi32\fP h, RGFW_windowFlags flags, \fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_surface\fP * \fBRGFW_window_createSurface\fP (\fBRGFW_window\fP *win, \fBu8\fP *data, \fBi32\fP w, \fBi32\fP h, RGFW_format format)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_createSurfacePtr\fP (\fBRGFW_window\fP *win, \fBu8\fP *data, \fBi32\fP w, \fBi32\fP h, RGFW_format format, \fBRGFW_surface\fP *surface)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_blitSurface\fP (\fBRGFW_window\fP *win, \fBRGFW_surface\fP *surface)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_getPosition\fP (\fBRGFW_window\fP *win, \fBi32\fP *x, \fBi32\fP *y)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_getSize\fP (\fBRGFW_window\fP *win, \fBi32\fP *w, \fBi32\fP *h)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBu32\fP \fBRGFW_window_getFlags\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP RGFW_key \fBRGFW_window_getExitKey\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setExitKey\fP (\fBRGFW_window\fP *win, RGFW_key key)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setEnabledEvents\fP (\fBRGFW_window\fP *win, RGFW_eventFlag events)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP RGFW_eventFlag \fBRGFW_window_getEnabledEvents\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setDisabledEvents\fP (\fBRGFW_window\fP *win, RGFW_eventFlag events)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setEventState\fP (\fBRGFW_window\fP *win, RGFW_eventFlag event, \fBRGFW_bool\fP state)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void * \fBRGFW_window_getUserPtr\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setUserPtr\fP (\fBRGFW_window\fP *win, void *ptr)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_window_src\fP * \fBRGFW_window_getSrc\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setLayer_OSX\fP (\fBRGFW_window\fP *win, void *layer)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void * \fBRGFW_window_getView_OSX\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void * \fBRGFW_window_getWindow_OSX\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void * \fBRGFW_window_getHWND\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void * \fBRGFW_window_getHDC\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBu64\fP \fBRGFW_window_getWindow_X11\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP struct wl_surface * \fBRGFW_window_getWindow_Wayland\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setFlags\fP (\fBRGFW_window\fP *win, RGFW_windowFlags)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_checkEvent\fP (\fBRGFW_window\fP *win, \fBRGFW_event\fP *event)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_checkQueuedEvent\fP (\fBRGFW_window\fP *win, \fBRGFW_event\fP *event)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isKeyPressed\fP (\fBRGFW_window\fP *win, RGFW_key key)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isKeyDown\fP (\fBRGFW_window\fP *win, RGFW_key key)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isKeyReleased\fP (\fBRGFW_window\fP *win, RGFW_key key)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isMousePressed\fP (\fBRGFW_window\fP *win, RGFW_mouseButton button)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isMouseDown\fP (\fBRGFW_window\fP *win, RGFW_mouseButton button)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isMouseReleased\fP (\fBRGFW_window\fP *win, RGFW_mouseButton button)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_didMouseLeave\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_didMouseEnter\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isMouseInside\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isDataDragging\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_getDataDrag\fP (\fBRGFW_window\fP *win, \fBi32\fP *x, \fBi32\fP *y)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_didDataDrop\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_getDataDrop\fP (\fBRGFW_window\fP *win, const char ***files, size_t *count)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_close\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_closePtr\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_move\fP (\fBRGFW_window\fP *win, \fBi32\fP x, \fBi32\fP y)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_moveToMonitor\fP (\fBRGFW_window\fP *win, \fBRGFW_monitor\fP m)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_resize\fP (\fBRGFW_window\fP *win, \fBi32\fP w, \fBi32\fP h)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setAspectRatio\fP (\fBRGFW_window\fP *win, \fBi32\fP w, \fBi32\fP h)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setMinSize\fP (\fBRGFW_window\fP *win, \fBi32\fP w, \fBi32\fP h)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setMaxSize\fP (\fBRGFW_window\fP *win, \fBi32\fP w, \fBi32\fP h)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_focus\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isInFocus\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_raise\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_maximize\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setFullscreen\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP fullscreen)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_center\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_minimize\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_restore\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setFloating\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP floating)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setOpacity\fP (\fBRGFW_window\fP *win, \fBu8\fP opacity)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setBorder\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP border)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_borderless\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setDND\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP allow)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_allowsDND\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setMousePassthrough\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP passthrough)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setName\fP (\fBRGFW_window\fP *win, const char *name)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_setIcon\fP (\fBRGFW_window\fP *win, \fBu8\fP *data, \fBi32\fP w, \fBi32\fP h, RGFW_format format)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu8\fP, RGFW_icon)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_setIconEx\fP (\fBRGFW_window\fP *win, \fBu8\fP *data, \fBi32\fP w, \fBi32\fP h, RGFW_format format, RGFW_icon type)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setMouse\fP (\fBRGFW_window\fP *win, \fBRGFW_mouse\fP *mouse)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu8\fP, RGFW_mouseIcons)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_setMouseStandard\fP (\fBRGFW_window\fP *win, RGFW_mouseIcons mouse)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_setMouseDefault\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_holdMouse\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isHoldingMouse\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_unholdMouse\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_hide\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_show\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setShouldClose\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP shouldClose)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_getGlobalMouse\fP (\fBi32\fP *x, \fBi32\fP *y)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_getMouse\fP (\fBRGFW_window\fP *win, \fBi32\fP *x, \fBi32\fP *y)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_showMouse\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP show)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isMouseHidden\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_moveMouse\fP (\fBRGFW_window\fP *win, \fBi32\fP x, \fBi32\fP y)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_shouldClose\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isFullscreen\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isHidden\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isMinimized\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isMaximized\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isFloating\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_scaleToMonitor\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_monitor\fP \fBRGFW_window_getMonitor\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP const char * \fBRGFW_readClipboard\fP (size_t *size)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_ssize_t\fP \fBRGFW_readClipboardPtr\fP (char *str, size_t strCapacity)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_writeClipboard\fP (const char *text, \fBu32\fP textLen)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu8\fP, RGFW_debugType)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu8\fP, RGFW_errorCode)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_debugfunc\fP \fBRGFW_setDebugCallback\fP (\fBRGFW_debugfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_sendDebugInfo\fP (RGFW_debugType type, RGFW_errorCode err, const char *msg)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_windowMovedfunc\fP \fBRGFW_setWindowMovedCallback\fP (\fBRGFW_windowMovedfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_windowResizedfunc\fP \fBRGFW_setWindowResizedCallback\fP (\fBRGFW_windowResizedfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_windowQuitfunc\fP \fBRGFW_setWindowQuitCallback\fP (\fBRGFW_windowQuitfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_mousePosfunc\fP \fBRGFW_setMousePosCallback\fP (\fBRGFW_mousePosfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_windowRefreshfunc\fP \fBRGFW_setWindowRefreshCallback\fP (\fBRGFW_windowRefreshfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_focusfunc\fP \fBRGFW_setFocusCallback\fP (\fBRGFW_focusfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_mouseNotifyfunc\fP \fBRGFW_setMouseNotifyCallback\fP (\fBRGFW_mouseNotifyfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_dataDropfunc\fP \fBRGFW_setDataDropCallback\fP (\fBRGFW_dataDropfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_dataDragfunc\fP \fBRGFW_setDataDragCallback\fP (\fBRGFW_dataDragfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_keyfunc\fP \fBRGFW_setKeyCallback\fP (\fBRGFW_keyfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_mouseButtonfunc\fP \fBRGFW_setMouseButtonCallback\fP (\fBRGFW_mouseButtonfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_mouseScrollfunc\fP \fBRGFW_setMouseScrollCallback\fP (\fBRGFW_mouseScrollfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_windowMaximizedfunc\fP \fBRGFW_setWindowMaximizedCallback\fP (\fBRGFW_windowMaximizedfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_windowMinimizedfunc\fP \fBRGFW_setWindowMinimizedCallback\fP (\fBRGFW_windowMinimizedfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_windowRestoredfunc\fP \fBRGFW_setWindowRestoredCallback\fP (\fBRGFW_windowRestoredfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_scaleUpdatedfunc\fP \fBRGFW_setScaleUpdatedCallback\fP (\fBRGFW_scaleUpdatedfunc\fP func)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_setRootWindow\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_window\fP * \fBRGFW_getRootWindow\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_eventQueuePush\fP (const \fBRGFW_event\fP *event)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_eventQueueFlush\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_event\fP * \fBRGFW_eventQueuePop\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBu32\fP \fBRGFW_apiKeyToRGFW\fP (\fBu32\fP keycode)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBu32\fP \fBRGFW_rgfwToApiKey\fP (\fBu32\fP keycode)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBu8\fP \fBRGFW_rgfwToKeyChar\fP (\fBu32\fP keycode)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP size_t \fBRGFW_sizeofInfo\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBi32\fP \fBRGFW_init\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_deinit\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBi32\fP \fBRGFW_init_ptr\fP (\fBRGFW_info\fP *info)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_deinit_ptr\fP (\fBRGFW_info\fP *info)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_setInfo\fP (\fBRGFW_info\fP *info)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_info\fP * \fBRGFW_getInfo\fP (void)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define RGFW_ALLOC   malloc"

.SS "#define RGFW_ASSERT   assert"

.SS "#define RGFW_ATOF(num)   atof(num)"

.SS "#define RGFW_BIT(x)   (1 << (x))"

.SS "#define RGFW_BOOL(x)   (\fBRGFW_bool\fP)((x) != 0) /* force a value to be 0 or 1 */"

.SS "#define RGFW_BOOL_DEFINED"

.SS "#define RGFW_COCOA_FRAME_NAME   NULL"

.SS "#define RGFW_ENUM(type, name)   type name; enum"

.SS "#define RGFW_FALSE   (\fBRGFW_bool\fP)0"

.SS "#define RGFW_FREE   free"

.SS "#define RGFW_HEADER"

.SS "#define RGFW_INT_DEFINED"

.SS "#define RGFW_MAX_DROPS   260 /* max items you can drop at once */"

.SS "#define RGFW_MAX_MONITORS   6"

.SS "#define RGFW_MAX_PATH   260 /* max length of a path (for drag andn drop) */"

.SS "#define RGFW_MEMCPY(dist, src, len)   memcpy(dist, src, len)"

.SS "#define RGFW_MEMSET(ptr, value, num)   memset(ptr, value, num)"

.SS "#define RGFW_MIN(x, y)   ((x < y) ? x : y)"

.SS "#define RGFW_ROUND(x)   (\fBi32\fP)((x) >= 0 ? (x) + 0\&.5f : (x) \- 0\&.5f)"

.SS "#define RGFW_STRNCMP(s1, s2, max)   strncmp(s1, s2, max)"

.SS "#define RGFW_STRNCPY(dist, src, len)   strncpy(dist, src, len)"

.SS "#define RGFW_STRSTR(str, substr)   strstr(str, substr)"

.SS "#define RGFW_STRTOL(str, endptr, base)   strtol(str, endptr, base)"

.SS "#define RGFW_TRUE   (\fBRGFW_bool\fP)1"

.SS "#define RGFW_UNUSED(x)   (void)(x)"

.SS "#define RGFW_USERPTR   NULL"

.SS "#define RGFWDEF   inline"

.SH "Typedef Documentation"
.PP 
.SS "typedef int16_t \fBi16\fP"

.SS "typedef int32_t \fBi32\fP"

.SS "typedef int64_t \fBi64\fP"

.SS "typedef int8_t \fBi8\fP"

.SS "typedef \fBu8\fP \fBRGFW_bool\fP"

.SS "typedef struct \fBRGFW_commonEvent\fP \fBRGFW_commonEvent\fP"
Event structure(s) and union for checking/getting events 
.SS "typedef struct \fBRGFW_dataDragEvent\fP \fBRGFW_dataDragEvent\fP"

.SS "typedef struct \fBRGFW_dataDropEvent\fP \fBRGFW_dataDropEvent\fP"

.SS "typedef union \fBRGFW_event\fP \fBRGFW_event\fP"
\fBRGFW_event\fP union 
.SS "typedef struct \fBRGFW_keyEvent\fP \fBRGFW_keyEvent\fP"

.SS "typedef struct \fBRGFW_monitor\fP \fBRGFW_monitor\fP"
structure for monitor data 
.SS "typedef struct \fBRGFW_monitorMode\fP \fBRGFW_monitorMode\fP"

.SS "typedef void \fBRGFW_mouse\fP"
loads mouse icon from bitmap (similar to RGFW_window_setIcon)\&. Icon NOT resized by default 
.SS "typedef struct \fBRGFW_mouseButtonEvent\fP \fBRGFW_mouseButtonEvent\fP"

.SS "typedef struct \fBRGFW_mousePosEvent\fP \fBRGFW_mousePosEvent\fP"

.SS "typedef struct \fBRGFW_mouseScrollEvent\fP \fBRGFW_mouseScrollEvent\fP"

.SS "typedef struct \fBRGFW_nativeImage\fP \fBRGFW_nativeImage\fP"

.SS "typedef struct \fBRGFW_scaleUpdatedEvent\fP \fBRGFW_scaleUpdatedEvent\fP"

.SS "typedef struct \fBRGFW_surface\fP \fBRGFW_surface\fP"

.SS "typedef struct \fBRGFW_window\fP \fBRGFW_window\fP"

.SS "typedef struct \fBRGFW_window_src\fP \fBRGFW_window_src\fP"

.SS "typedef uint16_t \fBu16\fP"

.SS "typedef uint32_t \fBu32\fP"

.SS "typedef uint64_t \fBu64\fP"

.SS "typedef uint8_t \fBu8\fP"

.SH "Function Documentation"
.PP 
.SS "\fBRGFWDEF\fP void * RGFW_alloc (size_t size)"

.SS "\fBRGFWDEF\fP void RGFW_copyImageData (\fBu8\fP * dest_data, \fBi32\fP w, \fBi32\fP h, RGFW_format dest_format, \fBu8\fP * src_data, RGFW_format src_format)"
copy image to another image, respecting each image's format 
.SS "\fBRGFWDEF\fP \fBRGFW_surface\fP * RGFW_createSurface (\fBu8\fP * data, \fBi32\fP w, \fBi32\fP h, RGFW_format format)"

.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_createSurfacePtr (\fBu8\fP * data, \fBi32\fP w, \fBi32\fP h, RGFW_format format, \fBRGFW_surface\fP * surface)"

.SS "\fBRGFWDEF\fP \fBRGFW_window\fP * RGFW_createWindow (const char * name, \fBi32\fP x, \fBi32\fP y, \fBi32\fP w, \fBi32\fP h, RGFW_windowFlags flags)"
function to create a window and struct 
.SS "\fBRGFWDEF\fP \fBRGFW_window\fP * RGFW_createWindowPtr (const char * name, \fBi32\fP x, \fBi32\fP y, \fBi32\fP w, \fBi32\fP h, RGFW_windowFlags flags, \fBRGFW_window\fP * win)"
function to create a window (without allocating a window struct) 
.SS "typedef RGFW_ENUM (\fBi32\fP, RGFW_eventWait)"
for RGFW_the code is stupid and C++ waitForEvent waitMS -> Allows the function to keep checking for events even after there are no more events if waitMS == 0, the loop will not wait for events if waitMS > 0, the loop will wait that many miliseconds after there are no more events until it returns if waitMS == -1 or waitMS == the max size of an unsigned 32-bit int, the loop will not return until it gets another event 
.SS "typedef RGFW_ENUM (\fBu32\fP, RGFW_eventFlag)"

.SS "typedef RGFW_ENUM (\fBu32\fP, RGFW_windowFlags)"
Optional arguments for making a windows < the window doesn't have a border
.PP
< the window cannot be resized by the user
.PP
< the window supports drag and drop
.PP
the window should hide the mouse (can be toggled later on using \fCRGFW_window_showMouse\fP)
.PP
< the window is fullscreen by default
.PP
< the window is transparent (only properly works on X11 and MacOS, although it's meant for for windows)
.PP
center the window on the screen
.PP
scale the window to the screen
.PP
the window is hidden
.PP
< create a floating window
.PP
< focus the window when it's shown
.PP
< focus the window when it's shown
.PP
< if the window is in focus
.PP
< create an OpenGL context (you can also do this manually with RGFW_window_createContext_OpenGL)
.PP
< create an EGL context (you can also do this manually with RGFW_window_createContext_EGL)
.SS "typedef RGFW_ENUM (\fBu8\fP, RGFW_eventType)"
event codes
.PP
< no event has been sent
.PP
< a key has been released
.PP
key event note the code of the key pressed is stored in RGFW_event\&.key\&.value !!Keycodes defined at the bottom of the RGFW_HEADER part of this file!!
.PP
while a string version is stored in RGFW_event\&.key\&.valueString
.PP
RGFW_event\&.key\&.mod holds the current mod this means if CapsLock, NumLock are active or not
.PP
< a mouse button has been pressed (left,middle,right)
.PP
< a mouse button has been released (left,middle,right)
.PP
< a mouse scroll event
.PP
< the position of the mouse has been changed
.PP
mouse event note the x and y of the mouse can be found in the vector, RGFW_x, y
.PP
RGFW_event\&.button\&.value holds which mouse button was pressed
.PP
< the window was moved (by the user)
.PP
< the window was resized (by the user), [on WASM this means the browser was resized]
.PP
< window is in focus now
.PP
< window is out of focus now
.PP
< the user clicked the quit button
.PP
< a file has been dropped into the window
.PP
< the start of a drag and drop event, when the file is being dragged
.PP
< the window was maximized
.PP
< the window was minimized
.PP
< the window was restored
.PP
< content scale factor changed
.SS "typedef RGFW_ENUM (\fBu8\fP, RGFW_format)"
< 8-bit RGB (3 channels)
.PP
< 8-bit BGR (3 channels)
.PP
< 8-bit RGBA (4 channels)
.PP
< 8-bit RGBA (4 channels)
.PP
< 8-bit BGRA (4 channels)
.PP
< 8-bit BGRA (4 channels)
.SS "typedef RGFW_ENUM (\fBu8\fP, RGFW_key)"
key codes and mouse icon enums 
.SS "typedef RGFW_ENUM (\fBu8\fP, RGFW_keymod)"

.SS "typedef RGFW_ENUM (\fBu8\fP, RGFW_modeRequest)"
< scale the monitor size
.PP
< change the refresh rate
.PP
< change the monitor RGB bits size
.SS "typedef RGFW_ENUM (\fBu8\fP, RGFW_mouseButton)"
mouse button codes (RGFW_event\&.button\&.value) < left mouse button is pressed
.PP
< mouse-wheel-button is pressed
.PP
< right mouse button is pressed
.SS "\fBRGFWDEF\fP void RGFW_free (void * ptr)"

.SS "\fBRGFWDEF\fP void RGFW_freeMouse (\fBRGFW_mouse\fP * mouse)"

.SS "\fBRGFWDEF\fP struct wl_display * RGFW_getDisplay_Wayland (void)"

.SS "\fBRGFWDEF\fP void * RGFW_getDisplay_X11 (void)"

.SS "\fBRGFWDEF\fP void * RGFW_getLayer_OSX (void)"
These functions return data from _RGFW\&. They return NULL if the platform is not in use (e\&.g\&. when trying to get OSX data on Windows)\&. 
.SS "\fBRGFWDEF\fP \fBRGFW_monitor\fP * RGFW_getMonitors (size_t * len)"
get an array of all the monitors (max 6) 
.SS "\fBRGFWDEF\fP \fBRGFW_monitor\fP RGFW_getPrimaryMonitor (void)"
get the primary monitor 
.SS "\fBRGFWDEF\fP \fBRGFW_mouse\fP * RGFW_loadMouse (\fBu8\fP * data, \fBi32\fP w, \fBi32\fP h, RGFW_format format)"
frees RGFW_mouse data 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_monitor_requestMode (\fBRGFW_monitor\fP mon, \fBRGFW_monitorMode\fP mode, RGFW_modeRequest request)"
request a specific mode 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_monitor_scaleToWindow (\fBRGFW_monitor\fP mon, struct \fBRGFW_window\fP * win)"
scale monitor to window size 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_monitorModeCompare (\fBRGFW_monitorMode\fP mon, \fBRGFW_monitorMode\fP mon2, RGFW_modeRequest request)"
check if 2 monitor modes are the same 
.SS "\fBRGFWDEF\fP void RGFW_moveToMacOSResourceDir (void)"
(cocoa only) change directory to resource folder 
.SS "\fBRGFWDEF\fP void RGFW_pollEvents (void)"
check all the events until there are none left and updates window structure attributes adds them to a queue for RGFW_window_checkEvent to check if queueEvents is true 
.SS "\fBRGFWDEF\fP void RGFW_setClassName (const char * name)"
the class name for X11 and WinAPI\&. apps with the same class will be grouped by the WM by default the class name will == the root window's name 
.SS "\fBRGFWDEF\fP void RGFW_setQueueEvents (\fBRGFW_bool\fP queue)"
if you you want events to be queued or not\&. This is enabled when the queue is checked with RGFW_window_checkQueuedEvent or RGFW_window_checkEvent Otherwise it's disabled by default 
.SS "\fBRGFWDEF\fP void RGFW_setXInstName (const char * name)"
X11 instance name (window name will by used by default) 
.SS "\fBRGFWDEF\fP size_t RGFW_sizeofNativeImage (void)"

.SS "\fBRGFWDEF\fP size_t RGFW_sizeofSurface (void)"

.SS "\fBRGFWDEF\fP size_t RGFW_sizeofWindow (void)"

.SS "\fBRGFWDEF\fP size_t RGFW_sizeofWindowSrc (void)"

.SS "\fBRGFWDEF\fP void RGFW_stopCheckEvents (void)"
tell RGFW_waitForEvent to stop waiting (to be ran from another thread) 
.SS "\fBRGFWDEF\fP void RGFW_surface_free (\fBRGFW_surface\fP * surface)"
free the surface pointer and buffers used for software rendering within the window 
.SS "\fBRGFWDEF\fP void RGFW_surface_freePtr (\fBRGFW_surface\fP * surface)"
free only the buffers used for software rendering within the window 
.SS "\fBRGFWDEF\fP \fBRGFW_nativeImage\fP * RGFW_surface_getNativeImage (\fBRGFW_surface\fP * surface)"

.SS "\fBRGFWDEF\fP void RGFW_useWayland (\fBRGFW_bool\fP wayland)"
(unix) Toggle use of wayland\&. This will be on by default if you use \fCRGFW_WAYLAND\fP (if you don't use RGFW_WAYLAND, you don't expose WAYLAND functions) this is mostly used to allow you to force the use of XWayland 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_usingWayland (void)"

.SS "\fBRGFWDEF\fP void RGFW_waitForEvent (\fBi32\fP waitMS)"
sleep until RGFW gets an event or the timer ends (defined by OS) 
.SS "\fBRGFWDEF\fP void RGFW_window_blitSurface (\fBRGFW_window\fP * win, \fBRGFW_surface\fP * surface)"
render the software rendering buffer 
.SS "\fBRGFWDEF\fP \fBRGFW_surface\fP * RGFW_window_createSurface (\fBRGFW_window\fP * win, \fBu8\fP * data, \fBi32\fP w, \fBi32\fP h, RGFW_format format)"

.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_createSurfacePtr (\fBRGFW_window\fP * win, \fBu8\fP * data, \fBi32\fP w, \fBi32\fP h, RGFW_format format, \fBRGFW_surface\fP * surface)"

.SS "\fBRGFWDEF\fP RGFW_eventFlag RGFW_window_getEnabledEvents (\fBRGFW_window\fP * win)"
gets all enabled events RGFW_window\&._enabledEvents (returns RGFW_window\&._enabledEvents) 
.SS "\fBRGFWDEF\fP RGFW_key RGFW_window_getExitKey (\fBRGFW_window\fP * win)"
get the exit key for the window | returns RGFW_window\&.exitKey 
.SS "\fBRGFWDEF\fP \fBu32\fP RGFW_window_getFlags (\fBRGFW_window\fP * win)"
gets the flags of the window | returns RGFW_window\&._flags 
.SS "\fBRGFWDEF\fP void * RGFW_window_getHDC (\fBRGFW_window\fP * win)"

.SS "\fBRGFWDEF\fP void * RGFW_window_getHWND (\fBRGFW_window\fP * win)"

.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_getPosition (\fBRGFW_window\fP * win, \fBi32\fP * x, \fBi32\fP * y)"
gets the position of the window | with RGFW_window\&.x and window\&.y 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_getSize (\fBRGFW_window\fP * win, \fBi32\fP * w, \fBi32\fP * h)"
gets the size of the window | with RGFW_window\&.w and window\&.h 
.SS "\fBRGFWDEF\fP \fBRGFW_window_src\fP * RGFW_window_getSrc (\fBRGFW_window\fP * win)"
returns fat pointer of window, which is sourced from the window casted to the fast pointer 
.SS "\fBRGFWDEF\fP void * RGFW_window_getUserPtr (\fBRGFW_window\fP * win)"
gets the userPtr of the window | returns RGFW_window\&.userPtr 
.SS "\fBRGFWDEF\fP void * RGFW_window_getView_OSX (\fBRGFW_window\fP * win)"

.SS "\fBRGFWDEF\fP void * RGFW_window_getWindow_OSX (\fBRGFW_window\fP * win)"

.SS "\fBRGFWDEF\fP struct wl_surface * RGFW_window_getWindow_Wayland (\fBRGFW_window\fP * win)"

.SS "\fBRGFWDEF\fP \fBu64\fP RGFW_window_getWindow_X11 (\fBRGFW_window\fP * win)"

.SS "\fBRGFWDEF\fP void RGFW_window_setDisabledEvents (\fBRGFW_window\fP * win, RGFW_eventFlag events)"
enables all events and then disables select events (modifies RGFW_window\&._enabledEvents) 
.SS "\fBRGFWDEF\fP void RGFW_window_setEnabledEvents (\fBRGFW_window\fP * win, RGFW_eventFlag events)"
sets the types of events you want to receive, RGFW_allEventFlags by default (modifies RGFW_window\&._enabledEvents) 
.SS "\fBRGFWDEF\fP void RGFW_window_setEventState (\fBRGFW_window\fP * win, RGFW_eventFlag event, \fBRGFW_bool\fP state)"
directly enables or disabled a specific event, (or cluster of events) (modifies RGFW_window\&._enabledEvents 
.SS "\fBRGFWDEF\fP void RGFW_window_setExitKey (\fBRGFW_window\fP * win, RGFW_key key)"
set the exit key for the window |edits RGFW_window\&.exitKey 
.SS "\fBRGFWDEF\fP void RGFW_window_setLayer_OSX (\fBRGFW_window\fP * win, void * layer)"

.SS "\fBRGFWDEF\fP void RGFW_window_setUserPtr (\fBRGFW_window\fP * win, void * ptr)"
sets the userPtr of the window | writes to RGFW_window\&.userPtr 
.SH "Author"
.PP 
Generated automatically by Doxygen for RGFW from the source code\&.
