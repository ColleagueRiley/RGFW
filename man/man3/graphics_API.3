.TH "graphics_API" 3 "Tue Jul 15 2025" "RGFW" \" -*- nroff -*-
.ad l
.nh
.SH NAME
graphics_API \- Graphics_API
.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void(* \fBRGFW_proc\fP) (void)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_makeCurrent\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_window\fP * \fBRGFW_getCurrent\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_swapBuffers\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_swapInterval\fP (\fBRGFW_window\fP *win, \fBi32\fP swapInterval)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_swapBuffers_software\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_initOpenGL\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_freeOpenGL\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu8\fP, RGFW_glHints)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_setGLHint\fP (RGFW_glHints hint, \fBi32\fP value)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_extensionSupported\fP (const char *extension, size_t len)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_proc\fP \fBRGFW_getProcAddress\fP (const char *procname)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_makeCurrent_OpenGL\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_swapBuffers_OpenGL\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "void * \fBRGFW_getCurrent_OpenGL\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_extensionSupportedPlatform\fP (const char *extension, size_t len)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.IP "\(bu" 2

.PP

.SH "Typedef Documentation"
.PP 
.SS "typedef void(* RGFW_proc) (void)"

.SH "Function Documentation"
.PP 
.SS "typedef RGFW_ENUM (\fBu8\fP, RGFW_glHints)"
OpenGL init hints < set stencil buffer bit size (8 by default)
.PP
< set number of sampiling buffers (4 by default)
.PP
< use GL_STEREO (GL_FALSE by default)
.PP
< number of aux buffers (0 by default)
.PP
< request double buffering
.PP
< set RGBA bit sizes
.PP
< set accumulated RGBA bit sizes
.PP
< request sRGA
.PP
< request a robust context
.PP
< request opengl debugging
.PP
< request no opengl errors
.PP
< the final hint (not for setting)
.PP
< RGFW_glProfile options
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_extensionSupported (const char * extension, size_t len)"
check if whether the specified API extension is supported by the current OpenGL or OpenGL ES context 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_extensionSupportedPlatform (const char * extension, size_t len)"
check if whether the specified platform-specific API extension is supported by the current OpenGL or OpenGL ES context 
.SS "\fBRGFWDEF\fP \fBRGFW_window\fP * RGFW_getCurrent (void)"
get current RGFW window graphics context 
.SS "void * RGFW_getCurrent_OpenGL (void)"
get the current context (OpenGL backend (GLX) (WGL) (EGL) (cocoa) (webgl)) 
.SS "\fBRGFWDEF\fP \fBRGFW_proc\fP RGFW_getProcAddress (const char * procname)"
get native opengl proc address 
.SS "\fBRGFWDEF\fP void RGFW_setGLHint (RGFW_glHints hint, \fBi32\fP value)"

.SS "\fBRGFWDEF\fP void RGFW_window_freeOpenGL (\fBRGFW_window\fP * win)"

.SS "\fBRGFWDEF\fP void RGFW_window_initOpenGL (\fBRGFW_window\fP * win)"
native API functions
.PP
< create an opengl context for the RGFW window, run by createWindow by default (unless the RGFW_windowNoInitAPI is included) called by \fCRGFW_window_close\fP by default (unless the RGFW_windowNoInitAPI is set) 
.SS "\fBRGFWDEF\fP void RGFW_window_makeCurrent (\fBRGFW_window\fP * win)"
< make the window the current opengl drawing context
.PP
NOTE: if you want to switch the graphics context's thread, you have to run RGFW_window_makeCurrent(NULL); on the old thread then RGFW_window_makeCurrent(valid_window) on the new thread 
.SS "\fBRGFWDEF\fP void RGFW_window_makeCurrent_OpenGL (\fBRGFW_window\fP * win)"
to be called by RGFW_window_makeCurrent 
.SS "\fBRGFWDEF\fP void RGFW_window_swapBuffers (\fBRGFW_window\fP * win)"
swap the rendering buffer 
.SS "\fBRGFWDEF\fP void RGFW_window_swapBuffers_OpenGL (\fBRGFW_window\fP * win)"
swap opengl buffer (only) called by RGFW_window_swapInterval 
.br
 
.SS "\fBRGFWDEF\fP void RGFW_window_swapBuffers_software (\fBRGFW_window\fP * win)"

.SS "\fBRGFWDEF\fP void RGFW_window_swapInterval (\fBRGFW_window\fP * win, \fBi32\fP swapInterval)"
render the software rendering buffer (this is called by RGFW_window_swapInterval) 
.br
 
.SH "Author"
.PP 
Generated automatically by Doxygen for RGFW from the source code\&.
