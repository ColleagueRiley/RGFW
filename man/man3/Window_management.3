.TH "Window_management" 3 "Sat Mar 29 2025" "RGFW" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Window_management \- Window_management
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_setClassName\fP (const char *name)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_setXInstName\fP (const char *name)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_moveToMacOSResourceDir\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_window\fP * \fBRGFW_createWindow\fP (const char *name, \fBRGFW_rect\fP rect, RGFW_windowFlags flags)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_window\fP * \fBRGFW_createWindowPtr\fP (const char *name, \fBRGFW_rect\fP rect, RGFW_windowFlags flags, \fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_initBuffer\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_initBufferSize\fP (\fBRGFW_window\fP *win, \fBRGFW_area\fP area)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_initBufferPtr\fP (\fBRGFW_window\fP *win, \fBu8\fP *buffer, \fBRGFW_area\fP area)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setFlags\fP (\fBRGFW_window\fP *win, RGFW_windowFlags)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_area\fP \fBRGFW_getScreenSize\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_event\fP * \fBRGFW_window_checkEvent\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu32\fP, RGFW_eventWait)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_eventWait\fP (\fBRGFW_window\fP *win, \fBu32\fP waitMS)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_checkEvents\fP (\fBRGFW_window\fP *win, \fBu32\fP waitMS)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_stopCheckEvents\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_close\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_move\fP (\fBRGFW_window\fP *win, \fBRGFW_point\fP v)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_moveToMonitor\fP (\fBRGFW_window\fP *win, \fBRGFW_monitor\fP m)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_resize\fP (\fBRGFW_window\fP *win, \fBRGFW_area\fP a)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setAspectRatio\fP (\fBRGFW_window\fP *win, \fBRGFW_area\fP a)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setMinSize\fP (\fBRGFW_window\fP *win, \fBRGFW_area\fP a)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setMaxSize\fP (\fBRGFW_window\fP *win, \fBRGFW_area\fP a)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_focus\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isInFocus\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_raise\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_maximize\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setFullscreen\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP fullscreen)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_center\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_minimize\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_restore\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setFloating\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP floating)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setOpacity\fP (\fBRGFW_window\fP *win, \fBu8\fP opacity)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setBorder\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP border)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_borderless\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setDND\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP allow)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_allowsDND\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setMousePassthrough\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP passthrough)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setName\fP (\fBRGFW_window\fP *win, const char *name)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_setIcon\fP (\fBRGFW_window\fP *win, \fBu8\fP *icon, \fBRGFW_area\fP a, \fBi32\fP channels)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu8\fP, RGFW_icon)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_setIconEx\fP (\fBRGFW_window\fP *win, \fBu8\fP *icon, \fBRGFW_area\fP a, \fBi32\fP channels, \fBu8\fP type)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setMouse\fP (\fBRGFW_window\fP *win, \fBRGFW_mouse\fP *mouse)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_setMouseStandard\fP (\fBRGFW_window\fP *win, \fBu8\fP mouse)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_setMouseDefault\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_mouseHold\fP (\fBRGFW_window\fP *win, \fBRGFW_area\fP area)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_mouseUnhold\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_hide\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_show\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setShouldClose\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP shouldClose)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_point\fP \fBRGFW_getGlobalMousePoint\fP (void)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_point\fP \fBRGFW_window_getMousePoint\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_showMouse\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP show)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_mouseHidden\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_moveMouse\fP (\fBRGFW_window\fP *win, \fBRGFW_point\fP v)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_shouldClose\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isFullscreen\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isHidden\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isMinimized\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isMaximized\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isFloating\fP (\fBRGFW_window\fP *win)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.IP "\(bu" 2

.PP

.SH "Function Documentation"
.PP 
.SS "\fBRGFWDEF\fP \fBRGFW_window\fP * RGFW_createWindow (const char * name, \fBRGFW_rect\fP rect, RGFW_windowFlags flags)"
function to create a window and struct 
.SS "\fBRGFWDEF\fP \fBRGFW_window\fP * RGFW_createWindowPtr (const char * name, \fBRGFW_rect\fP rect, RGFW_windowFlags flags, \fBRGFW_window\fP * win)"
function to create a window (without allocating a window struct) 
.SS "typedef RGFW_ENUM (\fBu32\fP, RGFW_eventWait)"
for RGFW_window_eventWait and RGFW_window_checkEvents waitMS -> Allows the function to keep checking for events even after \fCRGFW_window_checkEvent == NULL\fP if waitMS == 0, the loop will not wait for events if waitMS > 0, the loop will wait that many miliseconds after there are no more events until it returns if waitMS == -1 or waitMS == the max size of an unsigned 32-bit int, the loop will not return until it gets another event 
.SS "typedef RGFW_ENUM (\fBu8\fP, RGFW_icon)"

.SS "\fBRGFWDEF\fP \fBRGFW_point\fP RGFW_getGlobalMousePoint (void)"
where the mouse is on the screen 
.SS "\fBRGFWDEF\fP \fBRGFW_area\fP RGFW_getScreenSize (void)"
get the size of the screen to an area struct 
.SS "\fBRGFWDEF\fP void RGFW_moveToMacOSResourceDir (void)"
(cocoa only) change directory to resource folder 
.SS "\fBRGFWDEF\fP void RGFW_setClassName (const char * name)"
the class name for X11 and WinAPI\&. apps with the same class will be grouped by the WM by default the class name will == the root window's name 
.SS "\fBRGFWDEF\fP void RGFW_setXInstName (const char * name)"
X11 instance name (window name will by used by default) 
.SS "\fBRGFWDEF\fP void RGFW_stopCheckEvents (void)"
tell RGFW_window_eventWait to stop waiting (to be ran from another thread) 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_allowsDND (\fBRGFW_window\fP * win)"
check if DND is allowed 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_borderless (\fBRGFW_window\fP * win)"

.SS "\fBRGFWDEF\fP void RGFW_window_center (\fBRGFW_window\fP * win)"
center the window 
.SS "\fBRGFWDEF\fP \fBRGFW_event\fP * RGFW_window_checkEvent (\fBRGFW_window\fP * win)"
this function checks an \fIindividual\fP event (and updates window structure attributes) this means, using this function without a while loop may cause event lag
.PP
ex\&.
.PP
while (RGFW_window_checkEvent(win) != NULL) [this keeps checking events until it reaches the last one]
.PP
this function is optional if you choose to use event callbacks, although you still need some way to tell RGFW to process events eg\&. \fCRGFW_window_checkEvents\fP check current event (returns a pointer to win->event or NULL if there is no event) 
.SS "\fBRGFWDEF\fP void RGFW_window_checkEvents (\fBRGFW_window\fP * win, \fBu32\fP waitMS)"
check all the events until there are none left\&. This should only be used if you're using callbacks only 
.SS "\fBRGFWDEF\fP void RGFW_window_close (\fBRGFW_window\fP * win)"
window managment functions close the window and free leftover data 
.SS "\fBRGFWDEF\fP void RGFW_window_eventWait (\fBRGFW_window\fP * win, \fBu32\fP waitMS)"
sleep until RGFW gets an event or the timer ends (defined by OS) 
.SS "\fBRGFWDEF\fP void RGFW_window_focus (\fBRGFW_window\fP * win)"
sets the focus to this window 
.SS "\fBRGFWDEF\fP \fBRGFW_point\fP RGFW_window_getMousePoint (\fBRGFW_window\fP * win)"
where the mouse is on the window 
.SS "\fBRGFWDEF\fP void RGFW_window_hide (\fBRGFW_window\fP * win)"
hide the window 
.SS "\fBRGFWDEF\fP void RGFW_window_initBuffer (\fBRGFW_window\fP * win)"

.SS "\fBRGFWDEF\fP void RGFW_window_initBufferPtr (\fBRGFW_window\fP * win, \fBu8\fP * buffer, \fBRGFW_area\fP area)"

.SS "\fBRGFWDEF\fP void RGFW_window_initBufferSize (\fBRGFW_window\fP * win, \fBRGFW_area\fP area)"

.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_isFloating (\fBRGFW_window\fP * win)"
if the window is floating 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_isFullscreen (\fBRGFW_window\fP * win)"
if the window is fullscreen 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_isHidden (\fBRGFW_window\fP * win)"
if the window is hidden 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_isInFocus (\fBRGFW_window\fP * win)"
checks the focus to this window 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_isMaximized (\fBRGFW_window\fP * win)"
if the window is maximized 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_isMinimized (\fBRGFW_window\fP * win)"
if the window is minimized 
.SS "\fBRGFWDEF\fP void RGFW_window_maximize (\fBRGFW_window\fP * win)"
maximize the window 
.SS "\fBRGFWDEF\fP void RGFW_window_minimize (\fBRGFW_window\fP * win)"
minimize the window (in taskbar (per OS)) 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_mouseHidden (\fBRGFW_window\fP * win)"
if the mouse is hidden 
.SS "\fBRGFWDEF\fP void RGFW_window_mouseHold (\fBRGFW_window\fP * win, \fBRGFW_area\fP area)"

.SS "\fBRGFWDEF\fP void RGFW_window_mouseUnhold (\fBRGFW_window\fP * win)"
stop holding the mouse and let it move freely 
.SS "\fBRGFWDEF\fP void RGFW_window_move (\fBRGFW_window\fP * win, \fBRGFW_point\fP v)"
move a window to a given point 
.PP
\fBParameters\fP
.RS 4
\fIv\fP new pos 
.RE
.PP

.SS "\fBRGFWDEF\fP void RGFW_window_moveMouse (\fBRGFW_window\fP * win, \fBRGFW_point\fP v)"
move the mouse to a given point 
.SS "\fBRGFWDEF\fP void RGFW_window_moveToMonitor (\fBRGFW_window\fP * win, \fBRGFW_monitor\fP m)"
move window to a specific monitor 
.SS "\fBRGFWDEF\fP void RGFW_window_raise (\fBRGFW_window\fP * win)"
raise the window (to the top) 
.SS "\fBRGFWDEF\fP void RGFW_window_resize (\fBRGFW_window\fP * win, \fBRGFW_area\fP a)"
resize window to a current size/area 
.PP
\fBParameters\fP
.RS 4
\fIwin\fP source window
.br
\fIa\fP new size 
.RE
.PP

.SS "\fBRGFWDEF\fP void RGFW_window_restore (\fBRGFW_window\fP * win)"
restore the window from minimized (per OS) 
.SS "\fBRGFWDEF\fP void RGFW_window_setAspectRatio (\fBRGFW_window\fP * win, \fBRGFW_area\fP a)"
set window aspect ratio 
.SS "\fBRGFWDEF\fP void RGFW_window_setBorder (\fBRGFW_window\fP * win, \fBRGFW_bool\fP border)"
if the window should have a border or not (borderless) based on bool value of \fCborder\fP 
.SS "\fBRGFWDEF\fP void RGFW_window_setDND (\fBRGFW_window\fP * win, \fBRGFW_bool\fP allow)"
turn on / off dnd (RGFW_windowAllowDND stil must be passed to the window) 
.SS "\fBRGFWDEF\fP void RGFW_window_setFlags (\fBRGFW_window\fP * win, RGFW_windowFlags)"
set the window flags (will undo flags if they don't match the old ones) 
.SS "\fBRGFWDEF\fP void RGFW_window_setFloating (\fBRGFW_window\fP * win, \fBRGFW_bool\fP floating)"
make the window a floating window 
.SS "\fBRGFWDEF\fP void RGFW_window_setFullscreen (\fBRGFW_window\fP * win, \fBRGFW_bool\fP fullscreen)"
turn fullscreen on / off for a window 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_setIcon (\fBRGFW_window\fP * win, \fBu8\fP * icon, \fBRGFW_area\fP a, \fBi32\fP channels)"
image MAY be resized by default, set both the taskbar and window icon 
.PP
\fBParameters\fP
.RS 4
\fIwin\fP source window
.br
\fIicon\fP icon bitmap
.br
\fIa\fP width and height of the bitmap
.br
\fIchannels\fP how many channels the bitmap has (rgb : 3, rgba : 4) 
.RE
.PP

.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_setIconEx (\fBRGFW_window\fP * win, \fBu8\fP * icon, \fBRGFW_area\fP a, \fBi32\fP channels, \fBu8\fP type)"
sets mouse to RGFW_mouse icon (loaded from a bitmap struct) 
.SS "\fBRGFWDEF\fP void RGFW_window_setMaxSize (\fBRGFW_window\fP * win, \fBRGFW_area\fP a)"
set the maximum dimensions of a window 
.SS "\fBRGFWDEF\fP void RGFW_window_setMinSize (\fBRGFW_window\fP * win, \fBRGFW_area\fP a)"
set the minimum dimensions of a window 
.SS "\fBRGFWDEF\fP void RGFW_window_setMouse (\fBRGFW_window\fP * win, \fBRGFW_mouse\fP * mouse)"
sets the mouse to a standard API cursor (based on RGFW_MOUSE, as seen at the end of the RGFW_HEADER part of this file) 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_setMouseDefault (\fBRGFW_window\fP * win)"
sets the mouse to the default mouse icon 
.SS "\fBRGFWDEF\fP void RGFW_window_setMousePassthrough (\fBRGFW_window\fP * win, \fBRGFW_bool\fP passthrough)"
turn on / off mouse passthrough 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_setMouseStandard (\fBRGFW_window\fP * win, \fBu8\fP mouse)"

.SS "\fBRGFWDEF\fP void RGFW_window_setName (\fBRGFW_window\fP * win, const char * name)"
rename window to a given string 
.SS "\fBRGFWDEF\fP void RGFW_window_setOpacity (\fBRGFW_window\fP * win, \fBu8\fP opacity)"
sets the opacity of a window 
.SS "\fBRGFWDEF\fP void RGFW_window_setShouldClose (\fBRGFW_window\fP * win, \fBRGFW_bool\fP shouldClose)"

.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_shouldClose (\fBRGFW_window\fP * win)"
if the window should close (RGFW_close was sent or escape was pressed) 
.SS "\fBRGFWDEF\fP void RGFW_window_show (\fBRGFW_window\fP * win)"
show the window 
.SS "\fBRGFWDEF\fP void RGFW_window_showMouse (\fBRGFW_window\fP * win, \fBRGFW_bool\fP show)"
show the mouse or hide the mouse 
.SH "Author"
.PP 
Generated automatically by Doxygen for RGFW from the source code\&.
