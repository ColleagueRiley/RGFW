.TH "Window_management" 3 "Mon Aug 11 2025" "RGFW" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Window_management \- Window_management
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setFlags\fP (\fBRGFW_window\fP *win, RGFW_windowFlags)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_checkEvent\fP (\fBRGFW_window\fP *win, \fBRGFW_event\fP *event)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_checkQueuedEvent\fP (\fBRGFW_window\fP *win, \fBRGFW_event\fP *event)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isKeyPressed\fP (\fBRGFW_window\fP *win, RGFW_key key)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isKeyDown\fP (\fBRGFW_window\fP *win, RGFW_key key)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isKeyReleased\fP (\fBRGFW_window\fP *win, RGFW_key key)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isMousePressed\fP (\fBRGFW_window\fP *win, RGFW_mouseButton button)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isMouseDown\fP (\fBRGFW_window\fP *win, RGFW_mouseButton button)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isMouseReleased\fP (\fBRGFW_window\fP *win, RGFW_mouseButton button)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_close\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_closePtr\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_move\fP (\fBRGFW_window\fP *win, \fBi32\fP x, \fBi32\fP y)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_moveToMonitor\fP (\fBRGFW_window\fP *win, \fBRGFW_monitor\fP m)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_resize\fP (\fBRGFW_window\fP *win, \fBi32\fP w, \fBi32\fP h)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setAspectRatio\fP (\fBRGFW_window\fP *win, \fBi32\fP w, \fBi32\fP h)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setMinSize\fP (\fBRGFW_window\fP *win, \fBi32\fP w, \fBi32\fP h)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setMaxSize\fP (\fBRGFW_window\fP *win, \fBi32\fP w, \fBi32\fP h)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_focus\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isInFocus\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_raise\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_maximize\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setFullscreen\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP fullscreen)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_center\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_minimize\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_restore\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setFloating\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP floating)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setOpacity\fP (\fBRGFW_window\fP *win, \fBu8\fP opacity)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setBorder\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP border)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_borderless\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setDND\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP allow)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_allowsDND\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setMousePassthrough\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP passthrough)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setName\fP (\fBRGFW_window\fP *win, const char *name)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_setIcon\fP (\fBRGFW_window\fP *win, \fBu8\fP *data, \fBi32\fP w, \fBi32\fP h, RGFW_format format)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu8\fP, RGFW_icon)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_setIconEx\fP (\fBRGFW_window\fP *win, \fBu8\fP *data, \fBi32\fP w, \fBi32\fP h, RGFW_format format, RGFW_icon type)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setMouse\fP (\fBRGFW_window\fP *win, \fBRGFW_mouse\fP *mouse)"
.br
.ti -1c
.RI "typedef \fBRGFW_ENUM\fP (\fBu8\fP, RGFW_mouseIcons)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_setMouseStandard\fP (\fBRGFW_window\fP *win, RGFW_mouseIcons mouse)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_setMouseDefault\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_holdMouse\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isHoldingMouse\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_unholdMouse\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_hide\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_show\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_setShouldClose\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP shouldClose)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_getGlobalMouse\fP (\fBi32\fP *x, \fBi32\fP *y)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_getMouse\fP (\fBRGFW_window\fP *win, \fBi32\fP *x, \fBi32\fP *y)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_showMouse\fP (\fBRGFW_window\fP *win, \fBRGFW_bool\fP show)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isMouseHidden\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP void \fBRGFW_window_moveMouse\fP (\fBRGFW_window\fP *win, \fBi32\fP x, \fBi32\fP y)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_shouldClose\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isFullscreen\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isHidden\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isMinimized\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isMaximized\fP (\fBRGFW_window\fP *win)"
.br
.ti -1c
.RI "\fBRGFWDEF\fP \fBRGFW_bool\fP \fBRGFW_window_isFloating\fP (\fBRGFW_window\fP *win)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.IP "\(bu" 2

.PP

.SH "Function Documentation"
.PP 
.SS "typedef RGFW_ENUM (\fBu8\fP, RGFW_icon)"

.SS "typedef RGFW_ENUM (\fBu8\fP, RGFW_mouseIcons)"

.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_getGlobalMouse (\fBi32\fP * x, \fBi32\fP * y)"
where the mouse is on the screen 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_allowsDND (\fBRGFW_window\fP * win)"
check if DND is allowed 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_borderless (\fBRGFW_window\fP * win)"

.SS "\fBRGFWDEF\fP void RGFW_window_center (\fBRGFW_window\fP * win)"
center the window 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_checkEvent (\fBRGFW_window\fP * win, \fBRGFW_event\fP * event)"
polls the event queue if it's empty and pops the first event for the window from the event queue using this function without a while loop may cause event lag
.PP
because this function polls events, it may not work for multi-threaded systems RGFW_pollEvents + RGFW_window_checkQueuedEvent should be used when using multi-threaded systems
.PP
ex\&.
.PP
\fBRGFW_event\fP; while (RGFW_window_checkEvent(win, &event) != NULL) [this keeps checking events until it reaches the last queued event]
.PP
you may also use \fCRGFW_pollEvents\fP instead check current event (returns RGFW_TRUE if there is an event or RGFW_FALSE if there is no event) 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_checkQueuedEvent (\fBRGFW_window\fP * win, \fBRGFW_event\fP * event)"
pops the first event for the window from the event queue 
.SS "\fBRGFWDEF\fP void RGFW_window_close (\fBRGFW_window\fP * win)"
window managment functions close the window and free the window struct 
.SS "\fBRGFWDEF\fP void RGFW_window_closePtr (\fBRGFW_window\fP * win)"
close the window, don't free the window struct 
.SS "\fBRGFWDEF\fP void RGFW_window_focus (\fBRGFW_window\fP * win)"
sets the focus to this window 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_getMouse (\fBRGFW_window\fP * win, \fBi32\fP * x, \fBi32\fP * y)"
where the mouse is on the window 
.SS "\fBRGFWDEF\fP void RGFW_window_hide (\fBRGFW_window\fP * win)"
hide the window 
.SS "\fBRGFWDEF\fP void RGFW_window_holdMouse (\fBRGFW_window\fP * win)"

.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_isFloating (\fBRGFW_window\fP * win)"
if the window is floating 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_isFullscreen (\fBRGFW_window\fP * win)"
if the window is fullscreen 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_isHidden (\fBRGFW_window\fP * win)"
if the window is hidden 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_isHoldingMouse (\fBRGFW_window\fP * win)"
if the mouse is held by RGFW 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_isInFocus (\fBRGFW_window\fP * win)"
checks the focus to this window 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_isKeyDown (\fBRGFW_window\fP * win, RGFW_key key)"
if key is held (key code) 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_isKeyPressed (\fBRGFW_window\fP * win, RGFW_key key)"
checks only if the key is pressed while the window in focus\&. if key is pressed (key code) 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_isKeyReleased (\fBRGFW_window\fP * win, RGFW_key key)"
if key is released (key code) 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_isMaximized (\fBRGFW_window\fP * win)"
if the window is maximized 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_isMinimized (\fBRGFW_window\fP * win)"
if the window is minimized 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_isMouseDown (\fBRGFW_window\fP * win, RGFW_mouseButton button)"
if a mouse button is down 
.PP
\fBParameters\fP
.RS 4
\fIbutton\fP mouse button code 
.RE
.PP

.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_isMouseHidden (\fBRGFW_window\fP * win)"
if the mouse is hidden 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_isMousePressed (\fBRGFW_window\fP * win, RGFW_mouseButton button)"
if a mouse button is pressed 
.PP
\fBParameters\fP
.RS 4
\fIbutton\fP mouse button code 
.RE
.PP

.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_isMouseReleased (\fBRGFW_window\fP * win, RGFW_mouseButton button)"
if a mouse button was released 
.PP
\fBParameters\fP
.RS 4
\fIbutton\fP mouse button code 
.RE
.PP

.SS "\fBRGFWDEF\fP void RGFW_window_maximize (\fBRGFW_window\fP * win)"
maximize the window 
.SS "\fBRGFWDEF\fP void RGFW_window_minimize (\fBRGFW_window\fP * win)"
minimize the window (in taskbar (per OS)) 
.SS "\fBRGFWDEF\fP void RGFW_window_move (\fBRGFW_window\fP * win, \fBi32\fP x, \fBi32\fP y)"
move a window to a given point 
.PP
\fBParameters\fP
.RS 4
\fIy\fP new pos 
.RE
.PP

.SS "\fBRGFWDEF\fP void RGFW_window_moveMouse (\fBRGFW_window\fP * win, \fBi32\fP x, \fBi32\fP y)"
move the mouse to a given point 
.SS "\fBRGFWDEF\fP void RGFW_window_moveToMonitor (\fBRGFW_window\fP * win, \fBRGFW_monitor\fP m)"
move window to a specific monitor 
.SS "\fBRGFWDEF\fP void RGFW_window_raise (\fBRGFW_window\fP * win)"
raise the window (to the top) 
.SS "\fBRGFWDEF\fP void RGFW_window_resize (\fBRGFW_window\fP * win, \fBi32\fP w, \fBi32\fP h)"
resize window to a current size/area 
.PP
\fBParameters\fP
.RS 4
\fIwin\fP source window
.br
\fIh\fP new size 
.RE
.PP

.SS "\fBRGFWDEF\fP void RGFW_window_restore (\fBRGFW_window\fP * win)"
restore the window from minimized (per OS) 
.SS "\fBRGFWDEF\fP void RGFW_window_setAspectRatio (\fBRGFW_window\fP * win, \fBi32\fP w, \fBi32\fP h)"
set window aspect ratio 
.SS "\fBRGFWDEF\fP void RGFW_window_setBorder (\fBRGFW_window\fP * win, \fBRGFW_bool\fP border)"
if the window should have a border or not (borderless) based on bool value of \fCborder\fP 
.SS "\fBRGFWDEF\fP void RGFW_window_setDND (\fBRGFW_window\fP * win, \fBRGFW_bool\fP allow)"
turn on / off dnd (RGFW_windowAllowDND stil must be passed to the window) 
.SS "\fBRGFWDEF\fP void RGFW_window_setFlags (\fBRGFW_window\fP * win, RGFW_windowFlags)"
set the window flags (will undo flags if they don't match the old ones) 
.SS "\fBRGFWDEF\fP void RGFW_window_setFloating (\fBRGFW_window\fP * win, \fBRGFW_bool\fP floating)"
make the window a floating window 
.SS "\fBRGFWDEF\fP void RGFW_window_setFullscreen (\fBRGFW_window\fP * win, \fBRGFW_bool\fP fullscreen)"
turn fullscreen on / off for a window 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_setIcon (\fBRGFW_window\fP * win, \fBu8\fP * data, \fBi32\fP w, \fBi32\fP h, RGFW_format format)"

.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_setIconEx (\fBRGFW_window\fP * win, \fBu8\fP * data, \fBi32\fP w, \fBi32\fP h, RGFW_format format, RGFW_icon type)"
sets mouse to RGFW_mouse icon (loaded from a bitmap struct) 
.SS "\fBRGFWDEF\fP void RGFW_window_setMaxSize (\fBRGFW_window\fP * win, \fBi32\fP w, \fBi32\fP h)"
set the maximum dimensions of a window 
.SS "\fBRGFWDEF\fP void RGFW_window_setMinSize (\fBRGFW_window\fP * win, \fBi32\fP w, \fBi32\fP h)"
set the minimum dimensions of a window 
.SS "\fBRGFWDEF\fP void RGFW_window_setMouse (\fBRGFW_window\fP * win, \fBRGFW_mouse\fP * mouse)"

.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_setMouseDefault (\fBRGFW_window\fP * win)"
sets the mouse to the default mouse icon 
.SS "\fBRGFWDEF\fP void RGFW_window_setMousePassthrough (\fBRGFW_window\fP * win, \fBRGFW_bool\fP passthrough)"
turn on / off mouse passthrough 
.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_setMouseStandard (\fBRGFW_window\fP * win, RGFW_mouseIcons mouse)"
sets the mouse to a standard API cursor (based on RGFW_MOUSE, as seen at the end of the RGFW_HEADER part of this file) 
.SS "\fBRGFWDEF\fP void RGFW_window_setName (\fBRGFW_window\fP * win, const char * name)"
rename window to a given string image MAY be resized by default, set both the taskbar and window icon 
.SS "\fBRGFWDEF\fP void RGFW_window_setOpacity (\fBRGFW_window\fP * win, \fBu8\fP opacity)"
sets the opacity of a window 
.SS "\fBRGFWDEF\fP void RGFW_window_setShouldClose (\fBRGFW_window\fP * win, \fBRGFW_bool\fP shouldClose)"

.SS "\fBRGFWDEF\fP \fBRGFW_bool\fP RGFW_window_shouldClose (\fBRGFW_window\fP * win)"
if the window should close (RGFW_close was sent or escape was pressed) 
.SS "\fBRGFWDEF\fP void RGFW_window_show (\fBRGFW_window\fP * win)"
show the window 
.SS "\fBRGFWDEF\fP void RGFW_window_showMouse (\fBRGFW_window\fP * win, \fBRGFW_bool\fP show)"
show the mouse or hide the mouse 
.SS "\fBRGFWDEF\fP void RGFW_window_unholdMouse (\fBRGFW_window\fP * win)"
stop holding the mouse and let it move freely 
.SH "Author"
.PP 
Generated automatically by Doxygen for RGFW from the source code\&.
